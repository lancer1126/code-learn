# MySQL

### 1. 事务

MySQL 事务主要用于处理操作量大，复杂度高的数据。  
是逻辑上的一组操作，**要么都执行，要么都不执行**。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务。

#### 1.1 ACID

事务必须满足4个条件(ACID)：**原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。**  

* **原子性**：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。  
* **一致性**：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
* **隔离性**：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
* **持久性**：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

#### 1.2 事务控制

* BEGIN 或 START TRANSACTION 显式地开启一个事务
* COMMIT 也可以使用 COMMIT WORK，二者是等价。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的
* ROLLBACK 或 ROLLBACK WORK，二者等价。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改
* SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT
* RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出异常
* ROLLBACK TO identifier 把事务回滚到标记点
* SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。

#### 1.3 并发事务带来的问题

* **脏读（Dirty read）**: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还**没有提交到数据库中**，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
* **丢失修改（Lost to modify）**: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。
* **不可重复读（Unrepeatableread）**: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
* **幻读（Phantom read）**: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

#### 1.4 事务隔离级别

* **READ-UNCOMMITTED(读取未提交)**： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
* **READ-COMMITTED(读取已提交)**： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
* **REPEATABLE-READ(可重复读)**： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
* **SERIALIZABLE(可串行化)**： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。  

![QqWuQS.png](https://s2.ax1x.com/2019/12/19/QqWuQS.png)  
MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**。  
InnoDB 存储引擎在**分布式事务**的情况下一般会用到 SERIALIZABLE(可串行化) 隔离级别。

### 2. 大表优化

#### 2.1 限定数据的范围

禁止不带任何限制数据范围条件的查询语句。比如：当用户在查询订单历史的时候，我们可以控制在一个月的范围内；

#### 2.2  读/写分离

经典的数据库拆分方案，主库负责写，从库负责读；

#### 2.3  垂直分区

根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。

简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。  

![chui](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9E%82%E7%9B%B4%E5%88%86%E5%8C%BA.png)

* 优点： 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。
* 缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂

#### 2.4 水平分区

**保持数据表结构不变，通过某种策略存储数据分片**。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。

水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。  

![shui](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B0%B4%E5%B9%B3%E6%8B%86%E5%88%86.png)  

水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以**水平拆分最好分库 。**

### EXPLAIN命令

#### 简介

可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.

#### 关键字

[![QD7xHA.md.png](https://s2.ax1x.com/2019/12/10/QD7xHA.md.png)](https://imgse.com/i/QD7xHA)

1. **id**  
select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序  
    * id相同，执行顺序由上至下  
    * id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行  
    * id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行
2. **select_type**  
表示查询的类型，主要是用于区别普通查询，联合查询，子查询等复杂查询
    * ***SIMPLE***：简单的select查询，查询中不包括子查询或者UNION
    * ***PRIMARY***：查询中若包含任何复杂的子部分，最外层查询被标记为此
    * ***SUBQUERY***：在SELECT或WHERE列表中包含了子查询
    * ***DERIVED***：在FROM列表中包含的子查询被标记为DERIVED，会递归这些子查询，把结果放在临时表中
    * ***UNION***：若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层的select责备标记为DERIVED
    * ***UBION RESULT***：从UNION中获取结果的SELECT  
3. **table**  
显示这一行的数据是哪张表的
4. **type**  
显示访问类型，显示的结果值效率**自好到坏**依次为：  
***system>const>eq_ref>ref***>fulltext>ref_or_null>idnex_merge>unique_subquery>index_subquery>***range>index>ALL***  
    * ***system***  
    表只有一行记录（等于系统表），是const类型的特例，可以忽略不计
    * ***const***  
    通过一次索引就能找到，用于比较primary key或者unique索引，因为只匹配一行数据，所以很快能将主键置于where列表中，mysql就能将该查询转换为一个常量
    * ***eq_ref***  
    唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描
    * ***ref***  
    非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也可以是一种索引访问，它返回所有匹配某个单独值的行，但是可能会找到多个复合条件的行。
    * ***range***  
    只检索**给定范围**的行，使用一个索引来选择行，key列显示使用了哪个索引  
    一般是在where语句中出现了between，<>，in等的查询
    * ***index***  
    与ALL一样都是读全表，但区别为index只**遍历索引树**，通常比ALL快，因为索引文件通常比数据文件小。虽然ALL和index都是读全表，但index是从索引中读取的，而ALL是从硬盘中读取的
    * ***ALL***：遍历全表
5. ***possible_keys***  
显示**可能**应用在这张表的索引，一个或多个。  
查询涉及的字段若存在索引，则该索引被列出，**但不一定被查询实际使用**。  
6. ***key***  
实际使用的索引，如果为NULL，则没有使用索引  
查询中若使用了覆盖索引，则该索引只出现在key列表中，不会在possible_keys中
7. ***key_len***  
表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度，在不损失精确性的情况下，长度越短越好。  
显示的值为索引字段的最大可能长度，而非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的。
8. ***ref***  
哪些列或者敞亮被用于查找索引列上的值
9. ***rows***  
根据表统计信息及索引选用情况，大致估算出所求记录需要读取的行数
10. ***Extra***  
    * Using filesort：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。mysql中无法使用索引完成的排序操作称为文件排序。
    * Using temporary：使用临时表保存中间结果，mysql在对查询结果排序时使用临时表，常见域order by和group by
    * Using index：表示相应的select操作中使用了覆盖索引，避免访问表的数据行，效率较好。  
    如果同时出现using where，表名索引被用来执行索引键值的查找


## 索引

### 索引基本原理

索引是用来快速寻找那些具有特定值的记录，如果没有索引，那便是遍历整张表。  
是将无序的数据进行有序的查找。 

1. 把创建了索引的列的内容进行排序
2. 对排序结果生成倒排表
3. 在倒排表内容上拼上数据地址链
4. 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据

### B+树索引

#### 1. B+树性质

1. n子节点都包含n个关键字，但是不用来保存数据而是保存对数据的索引。
2. 叶节点中保存着所有关键字的数据，以及指向这些关键字记录的指针，并且也按照键值大小自左向右存放在同一层级中。
3. 所有的非终端节点都可以看成是索引部分。
4. B+树中，所有的插入和删除操作都在叶节点中进行。
5. B+树有两个头指针，一个是根节点，一个是最小关键码的叶节点。

#### 2. B+树索引与哈希索引的不同

1. 在等值查询中，哈希索引有明显优势，因为只需要一次算法即可找到对应的键值。但是在存在大量的重复键值的时候，效率会比较低，因为存在哈希碰撞问题。
2. 若是范围查询，哈希索引则无用处，因为原先有序的键值经过哈希算法后可能会变成不连续的。
3. 哈希索引也无法利用索引完成排序。
4. 哈希索引不支持多表联合索引的最左匹配原则
5. B+树的索引查询比较平均，不像B树浮动较大。

### 索引优化

#### 注意事项

1. 全值匹配
2. 最佳左前缀法则
3. 不在索引列上做任何操作（计算，函数，类型转换），会导致索引失效而转向全表扫描
4. 存储引擎不能使用索引中范围条件右边的列
5. 尽量使用覆盖索引（只访问索引中的查询（索引列和查询列一致）），避免使用select *
6. mysql在使用范围查询时（！= 或者< >，like）时无法使用索引
7. is null, isnot null无法使用索引
8. 字符串不加单引号索引失效
9. 少用or，用它连接时会索引失效
