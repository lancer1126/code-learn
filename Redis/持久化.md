# Redis持久化

Redis 提供了不同级别的持久化方式:

**RDB持久化方式**能够在指定的时间间隔能对你的数据进行快照存储.  
**AOF持久化方式**记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大.

## RDB(Redis DataBase)  

**是什么**

* 在指定时间间隔内将内存中的数据集快照写入磁盘，即snapshot快照，它恢复时是将快照文件直接读到内存里  
* redis会单独创建(fork)一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化进程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了较高的性能。  
* 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是很敏感，那RDB方法要比AOF更加高效。RDB的缺点是最后一次持久化后的数据可能丢失。

***Fork***  
复制一个与当前进程一样的进程，新进程的所有数据数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。  

**优势**  

1. RDB是一个非常紧凑的文件,它保存了某个时间点得数据集,非常适用于数据集的备份,比如你可以在每个小时报保存一下过去24小时内的数据,同时每天保存过去30天的数据,这样即使出了问题你也可以根据需求恢复到不同版本的数据集.
2. RDB是一个紧凑的单一文件,很方便传送到另一个远端数据中心或者亚马逊的S3（可能加密），非常适用于灾难恢复.  
3. RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程,接下来的工作全部由子进程来做，父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能.  
4. 与AOF相比,在恢复大的数据集的时候，RDB方式会更快一些.  

**劣势**

1. 虽然可以配置不同的save时间点(例如每隔5分钟并且对数据集有100个写的操作),是Redis要完整的保存整个数据集是一个比较繁重的工作,通常会每隔5分钟或者更久做一次完整的保存,万一在Redis意外宕机,你可能会丢失几分钟的数据.
2. RDB 需要经常fork子进程来保存数据集到硬盘上,当数据集比较大的时候,fork的过程是非常耗时的,可能会导致Redis在一些毫秒级内不能响应客户端的请求.如果数据集巨大并且CPU性能不是很好的情况下,这种情况会持续1秒,AOF也需要fork,但是你可以调节重写日志文件的频率来提高数据集的耐久度.

## AOF(Append Only File)

**AOF 优点**

1. 使用AOF 会让你的Redis更加耐久: 你可以使用不同的fsync策略：无fsync,每秒fsync,每次写的时候fsync.使用默认的每秒fsync策略,Redis的性能依然很好(fsync是由后台线程进行处理的,主线程会尽力处理客户端请求),一旦出现故障，你最多丢失1秒的数据.
2. AOF文件是一个只进行追加的日志文件,所以不需要写入seek,即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令,你也也可使用redis-check-aof工具修复这些问题.
3. Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。
4. AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。

**AOF 缺点**

1. 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。
2. 根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。

## 工作原理

AOF 重写和 RDB 创建快照一样，都巧妙地利用了**写时复制机制**:

1. Redis 执行 fork() ，现在同时拥有父进程和子进程。
2. 子进程开始将新 AOF 文件的内容写入到临时文件。
3. 对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾,这样样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。
4. 当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。
5. 搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。

## 选择使用哪种方式

一般来说，如果想达到足以媲美 PostgreSQL 的数据安全性，应该同时使用两种持久化功能。  

如果非常关心数据 但仍然可以承受数分钟以内的数据丢失，那么可以只使用 RDB 持久化。

不推荐只使用AOF：因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份，并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，除此之外，使用 RDB 还可以避免之前提到的 AOF 程序的 bug 。

## 总结

* RDB持久化方式能够在指定的时间间隔对你的数据进行快照存储。
* AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些操作来恢复原始的数据，AOF命令以Redis协议追加保存每次写的操作到文件末尾
* Redis能对AOF文件进行后台重写，使得AOF文件的体积不至于过大
* 只做缓存：如果希望数据在服务器运行的时候存在，也可以不使用这些持久化方式
* 同时开启两种方式
    * 在这种情况下，当redis重启时会优先加载AOF文件来恢复原始数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集完整。
    * RDB数据不实时，同时使用两者时服务器也只会找AOF文件，但是也不建议只使用AOF，因为RDB更适合用于备份数据库（AOF不断变化不好备份），而且不会有AOF潜在的BUG