# I/O

## 概念

**同步与异步**

* **同步**：发起一个调用后，被调用者未完成请求之前，调用不会返回
* **异步**：发起一个调用后，接到被调用者的回应表示已经接受请求，但是被调用者并不立即返回结果，此时可以处理其他的请求，被调用者依靠事件，回调等机制来通知调用者返回结果。

**阻塞与非阻塞**

* **阻塞**：发起一个请求，调用者需要一直等待请求结果返回，当前线程会被挂起，不能执行其他的任务，只能在条件达成时才能继续。
* **非阻塞**：发起一个请求，调用者不需要等待结果返回，可以先执行其他任务。

## 1.BIO(Blocking I/O)

同步阻塞I/O模式，数据的读写必须阻塞在一个线程内完成。

### 1.1 传统BIO

![bio](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2.png)  

![bio](https://upload-images.jianshu.io/upload_images/1089449-6377fd47256970ef.png?imageMogr2/auto-orient/strip|imageView2/2/w/584/format/webp)
  
采用 BIO 通信模型 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。通过在while(true) 循环中服务端会调用 accept() 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成， 不过可以通过多线程来支持多个客户端的连接

### 1.2 伪异步IO

对同步阻塞IO一个链路需要一个线程处理的问题进行了优化——后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M：线程池最大线程数N的比例关系，其中M可以远远大于N.通过线程池可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程耗尽。

![异步](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/3.png)  
采用线程池和任务队列可以实现一种叫做伪异步的 I/O 通信框架，它的模型图如上图所示。当有新的客户端接入时，将客户端的 Socket 封装成一个Task（该任务实现java.lang.Runnable接口）投递到后端的线程池中进行处理，JDK 的线程池维护一个消息队列和 N 个活跃线程，对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。

伪异步I/O通信框架采用了线程池实现，因此避免了为每个请求都创建一个独立线程造成的线程资源耗尽问题。不过因为它的底层仍然是同步阻塞的BIO模型，因此无法从根本上解决问题。

### 1.3 BIO小节

在活动连接数并不高的情况下(小于1000)，该模型可行，让每个连接专注于自己的IO，但是当面对百万以上的连接时，传统BIO无能为力。

***

## 2. NIO-Non-blocking I/O

### 2.1 简介

NIO是一种同步非阻塞IO模型，支持面向缓冲，基于通道的IO操作，NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。

### 2.2 NIO与IO的区别

#### 2.2.1 非阻塞IO(Non-blocking IO)

**IO流是阻塞的，NIO流时非阻塞的**  
NIO可以进行**非阻塞IO**操作，单线程从通道中读取数据到buffer，同时可以做其他的事，当读取到buffer完成后，线程可以继续处理数据，写入操作也是类似，不需要等到它完全写入。  

IO流是**阻塞**的，当一个线程调用read()或write()时，该线程被阻塞，除非写入或读取操作完成，否则不能做其他的事情。  

![b](https://upload-images.jianshu.io/upload_images/1089449-9eebe781fba495fd.png?imageMogr2/auto-orient/strip|imageView2/2/w/572/format/webp)

#### 2.2.2 缓冲区(Buffer)

**IO是面向流(Stream Oriented)，而NIO面向缓冲区(Buffer Oriented)**  
Buffer是一个对象，包含一些要写入或读出的数据，面向流的IO直接将数据写入/读出到Stream对象中，而NIO直接读取到Buffer中进行操作。  
在NIO中，将数据读入到缓冲器，使用通道进一步处理数据。

#### 2.2.3 通道(Channels)

在NIO中，通道是在实体和字节缓冲区之间有效传输数据的媒介，它从一个实体读取数据，并将其放在缓冲区块以供使用。

* 流只能用于单向数据传输。  
* 通道可以提供双向数据传输。

因此在NIO中使用通道，可以执行非阻塞IO操作。

#### 2.2.4 选择器(Selectors)

NIO有选择器，而IO没有。  
选择器是可选择通道的多路复用器，可用作进入非阻塞模式的特殊类型的通道，检查一个或多个NIO通道，并确定哪个准备好进行通信，即读取或写入。  
选择器用于使用单个线程处理多个通道，因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。

![s](https://upload-images.jianshu.io/upload_images/1089449-78814cbb3acc30bd.png?imageMogr2/auto-orient/strip|imageView2/2/w/525/format/webp)

### 2.3 NIO读写数据方式

通常来说NIO中的IO都是从Channel开始的。

* 从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。
* 从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。  

![rw](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/NIO%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F.png)
