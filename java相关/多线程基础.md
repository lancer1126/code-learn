# 多线程基础

## 1. 进程与线程

### 进程

进程是程序的一种执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。  
在java中，启动main函数就是启动了一个JVM的进程。

### 线程

线程是一个比进程更小的执行单位，一个进程在执行过程中可以产生多个线程，与进程不同的是同类的多个线程共享进程的堆和方法区资源，但是每个线程又有自己的程序计数器，虚拟机栈和本地方法栈，所以系统在各个线程之间切换工作时，负担比进程小得多，所以，线程也被称为轻量级进程。

## 2. 为什么使用多线程

* **从计算机底层来说**： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。
* **从当代互联网发展趋势来说**： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。  

深入到计算机底层：

* **单核时代**： 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。
* **多核时代**: 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。

## 3. 线程的生命周期和状态

1. **NEW**：初始状态，线程被构建，但在调用start()之前都是未启动状态
2. **RUNNABLE**：运行状态，Java线程将操作系统中的就绪和运行两种状态笼统的称为“运行中”。
3. **BLOCKED**：阻塞状态，表示线程阻塞于锁
4. **WAITTING**：等待状态，线程进入了等待状态，表示该线程需要等待其他线程做出一个特定动作（通知或中断）
5. TIME_WAITTING：超时等待状态，可以在指定的时间自行返回
6. **TERMINATE**：终止状态，表示当前线程已经执行完毕
[![MIwiid.md.png](https://s2.ax1x.com/2019/11/21/MIwiid.md.png)](https://imgchr.com/i/MIwiid)

## 4. 上下文切换

多线程中一般线程的个数都大于CPU核心的个数，而一个CPU在任意时刻都只能被一个线程使用，为了让这些线程都能得到有效执行，CPU采用的策略是为每个线程分配时间片并轮转的方式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就是一次上下文切换。  

概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。
  
上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。

## 5. 线程死锁

多个线程同时被阻塞，他们中的一个或全部都在等待某个资源被释放，由于线程被无限期地阻塞，因此程序不可能正常终止。

```java
public class DeadLockDemo {
    private static Object resource1 = new Object();//资源 1
    private static Object resource2 = new Object();//资源 2

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (resource1) {
                System.out.println(Thread.currentThread() + "get resource1");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource2");
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + "get resource2");
                }
            }
        }, "线程 1").start();

        new Thread(() -> {
            synchronized (resource2) {
                System.out.println(Thread.currentThread() + "get resource2");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource1");
                synchronized (resource1) {
                    System.out.println(Thread.currentThread() + "get resource1");
                }
            }
        }, "线程 2").start();
    }
}
```
线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过 Thread.sleep(1000);让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。  

***死锁条件***

1. 互斥条件：该资源任意一个时刻只有一个线程占用
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已经获得的资源不放开
3. 不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才能释放资源。
4. 循环等待条件：若干进程之间形成一个头尾相接的循环等待资源关系。

***如何避免死锁***

* **破坏互斥条件**：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。

* **破坏请求与保持条件**：一次性申请所有的资源。

* **破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。

* **破坏循环等待条件**：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

对上诉代码进行修改

```java
 new Thread(() -> {
            synchronized (resource1) {
                System.out.println(Thread.currentThread() + "get resource1");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource2");
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + "get resource2");
                }
            }
        }, "线程 2").start();
```

## 6. sleep()和wait()

1. 两者最主要的区别在于：sleep 方法没有释放锁，而 wait 方法释放了锁 。
2. 两者都可以暂停线程的执行。
3. Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。
4. wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。